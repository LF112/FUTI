/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Proprietary Software license
 * that can be found at https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.html.
 * 请注意，此 Live2D Code 非官方原版，已为适配 Vite 载入而更改部分代码。
 * Code Editor: LF112(lf@lf112.net)
 */
export var Live2DCubismCore;
(function (Live2DCubismCore) {
    /** C calls. */
    var _csm = /** @class */ (function () {
        function _csm() {
        }
        _csm.getVersion = function () {
            return _em.ccall("csmGetVersion", "number", [], []);
        };
        _csm.getLatestMocVersion = function () {
            return _em.ccall("csmGetLatestMocVersion", "number", [], []);
        };
        _csm.getMocVersion = function (moc) {
            return _em.ccall("csmGetMocVersion", "number", ["number"], [moc]);
        };
        _csm.getSizeofModel = function (moc) {
            return _em.ccall("csmGetSizeofModel", "number", ["number"], [moc]);
        };
        _csm.reviveMocInPlace = function (memory, mocSize) {
            return _em.ccall("csmReviveMocInPlace", "number", ["number", "number"], [memory, mocSize]);
        };
        _csm.initializeModelInPlace = function (moc, memory, modelSize) {
            return _em.ccall("csmInitializeModelInPlace", "number", ["number", "number", "number"], [moc, memory, modelSize]);
        };
        _csm.getParameterCount = function (model) {
            return _em.ccall("csmGetParameterCount", "number", ["number"], [model]);
        };
        _csm.getParameterIds = function (model) {
            return _em.ccall("csmGetParameterIds", "number", ["number"], [model]);
        };
        _csm.getParameterMinimumValues = function (model) {
            return _em.ccall("csmGetParameterMinimumValues", "number", ["number"], [model]);
        };
        _csm.getParameterMaximumValues = function (model) {
            return _em.ccall("csmGetParameterMaximumValues", "number", ["number"], [model]);
        };
        _csm.getParameterDefaultValues = function (model) {
            return _em.ccall("csmGetParameterDefaultValues", "number", ["number"], [model]);
        };
        _csm.getParameterValues = function (model) {
            return _em.ccall("csmGetParameterValues", "number", ["number"], [model]);
        };
        _csm.getParameterKeyCounts = function (model) {
            return _em.ccall("csmGetParameterKeyCounts", "number", ["number"], [model]);
        };
        _csm.getParameterKeyValues = function (model) {
            return _em.ccall("csmGetParameterKeyValues", "number", ["number"], [model]);
        };
        _csm.getPartCount = function (model) {
            return _em.ccall("csmGetPartCount", "number", ["number"], [model]);
        };
        _csm.getPartIds = function (model) {
            return _em.ccall("csmGetPartIds", "number", ["number"], [model]);
        };
        _csm.getPartOpacities = function (model) {
            return _em.ccall("csmGetPartOpacities", "number", ["number"], [model]);
        };
        _csm.getPartParentPartIndices = function (model) {
            return _em.ccall("csmGetPartParentPartIndices", "number", ["number"], [model]);
        };
        _csm.getDrawableCount = function (model) {
            return _em.ccall("csmGetDrawableCount", "number", ["number"], [model]);
        };
        _csm.getDrawableIds = function (model) {
            return _em.ccall("csmGetDrawableIds", "number", ["number"], [model]);
        };
        _csm.getDrawableConstantFlags = function (model) {
            return _em.ccall("csmGetDrawableConstantFlags", "number", ["number"], [model]);
        };
        _csm.getDrawableDynamicFlags = function (model) {
            return _em.ccall("csmGetDrawableDynamicFlags", "number", ["number"], [model]);
        };
        _csm.getDrawableTextureIndices = function (model) {
            return _em.ccall("csmGetDrawableTextureIndices", "number", ["number"], [model]);
        };
        _csm.getDrawableDrawOrders = function (model) {
            return _em.ccall("csmGetDrawableDrawOrders", "number", ["number"], [model]);
        };
        _csm.getDrawableRenderOrders = function (model) {
            return _em.ccall("csmGetDrawableRenderOrders", "number", ["number"], [model]);
        };
        _csm.getDrawableOpacities = function (model) {
            return _em.ccall("csmGetDrawableOpacities", "number", ["number"], [model]);
        };
        _csm.getDrawableMaskCounts = function (model) {
            return _em.ccall("csmGetDrawableMaskCounts", "number", ["number"], [model]);
        };
        _csm.getDrawableMasks = function (model) {
            return _em.ccall("csmGetDrawableMasks", "number", ["number"], [model]);
        };
        _csm.getDrawableVertexCounts = function (model) {
            return _em.ccall("csmGetDrawableVertexCounts", "number", ["number"], [model]);
        };
        _csm.getDrawableVertexPositions = function (model) {
            return _em.ccall("csmGetDrawableVertexPositions", "number", ["number"], [model]);
        };
        _csm.getDrawableVertexUvs = function (model) {
            return _em.ccall("csmGetDrawableVertexUvs", "number", ["number"], [model]);
        };
        _csm.getDrawableIndexCounts = function (model) {
            return _em.ccall("csmGetDrawableIndexCounts", "number", ["number"], [model]);
        };
        _csm.getDrawableIndices = function (model) {
            return _em.ccall("csmGetDrawableIndices", "number", ["number"], [model]);
        };
        _csm.mallocMoc = function (mocSize) {
            return _em.ccall("csmMallocMoc", "number", ["number"], [mocSize]);
        };
        _csm.mallocModelAndInitialize = function (moc) {
            return _em.ccall("csmMallocModelAndInitialize", "number", ["number"], [moc]);
        };
        _csm.malloc = function (size) {
            return _em.ccall("csmMalloc", "number", ["number"], [size]);
        };
        _csm.setLogFunction = function (handler) {
            _em.ccall("csmSetLogFunction", null, ["number"], [handler]);
        };
        _csm.updateModel = function (model) {
            _em.ccall("csmUpdateModel", null, ["number"], [model]);
        };
        _csm.readCanvasInfo = function (model, outSizeInPixels, outOriginInPixels, outPixelsPerUnit) {
            _em.ccall("csmReadCanvasInfo", null, ["number", "number", "number", "number"], [model, outSizeInPixels, outOriginInPixels, outPixelsPerUnit]);
        };
        _csm.resetDrawableDynamicFlags = function (model) {
            _em.ccall("csmResetDrawableDynamicFlags", null, ["number"], [model]);
        };
        _csm.free = function (memory) {
            _em.ccall("csmFree", null, ["number"], [memory]);
        };
        return _csm;
    }());
    ;
    /** Cubism version. */
    var Version = /** @class */ (function () {
        function Version() {
        }
        /**
         * Queries Core version.
         *
         * @return Core version.
         */
        Version.csmGetVersion = function () {
            return _csm.getVersion();
        };
        /**
         * Gets Moc file supported latest version.
         *
         * @return Moc file latest format version.
         */
        Version.csmGetLatestMocVersion = function () {
            return _csm.getLatestMocVersion();
        };
        /**
         * Gets Moc file format version.
         *
         * @param moc Moc
         *
         * @return csmMocVersion
         */
        Version.csmGetMocVersion = function (moc) {
            return _csm.getMocVersion(moc._ptr);
        };
        return Version;
    }());
    Live2DCubismCore.Version = Version;
    /** Cubism logging. */
    var Logging = /** @class */ (function () {
        function Logging() {
        }
        /**
         * Sets log handler.
         *
         * @param handler  Handler to use.
         */
        Logging.csmSetLogFunction = function (handler) {
            // Cache log handler.
            Logging.logFunction = handler;
            // Wrap function to pointer.
            var pointer = _em.addFunction(Logging.wrapLogFunction, 'vi');
            // Sets log handler.
            _csm.setLogFunction(pointer);
        };
        /**
         * Queries log handler.
         *
         * @return Log handler.
         */
        Logging.csmGetLogFunction = function () {
            return Logging.logFunction;
        };
        /**
         * Wrap log function.
         *
         * @param messagePtr number
         *
         * @return string
         */
        Logging.wrapLogFunction = function (messagePtr) {
            // Pointer to string.
            var messageStr = _em.UTF8ToString(messagePtr);
            // Run log function.
            Logging.logFunction(messageStr);
        };
        return Logging;
    }());
    Live2DCubismCore.Logging = Logging;
    /** Cubism moc. */
    var Moc = /** @class */ (function () {
        /**
         * Initializes instance.
         *
         * @param mocBytes Moc bytes.
         */
        function Moc(mocBytes) {
            // Allocate memory.
            var memory = _csm.mallocMoc(mocBytes.byteLength);
            if (!memory) {
                return;
            }
            // Initialize memory.
            var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
            destination.set(new Uint8Array(mocBytes));
            // Revive moc.
            this._ptr = _csm.reviveMocInPlace(memory, mocBytes.byteLength);
            if (!this._ptr) {
                _csm.free(memory);
            }
        }
        /** Creates [[Moc]] from [[ArrayBuffer]].
         *
         * @param buffer Array buffer
         *
         * @return [[Moc]] on success; [[null]] otherwise.
         */
        Moc.fromArrayBuffer = function (buffer) {
            if (!buffer) {
                return null;
            }
            var moc = new Moc(buffer);
            return (moc._ptr)
                ? moc
                : null;
        };
        /** Releases instance. */
        Moc.prototype._release = function () {
            _csm.free(this._ptr);
            this._ptr = 0;
        };
        return Moc;
    }());
    Live2DCubismCore.Moc = Moc;
    /** Cubism model. */
    var Model = /** @class */ (function () {
        /**
         * Initializes instance.
         *
         * @param moc Moc
         */
        function Model(moc) {
            this._ptr = _csm.mallocModelAndInitialize(moc._ptr);
            if (!this._ptr) {
                return;
            }
            this.parameters = new Parameters(this._ptr);
            this.parts = new Parts(this._ptr);
            this.drawables = new Drawables(this._ptr);
            this.canvasinfo = new CanvasInfo(this._ptr);
        }
        /**
         * Creates [[Model]] from [[Moc]].
         *
         * @param moc Moc
         *
         * @return [[Model]] on success; [[null]] otherwise.
         */
        Model.fromMoc = function (moc) {
            var model = new Model(moc);
            return (model._ptr)
                ? model
                : null;
        };
        /** Updates instance. */
        Model.prototype.update = function () {
            _csm.updateModel(this._ptr);
        };
        /** Releases instance. */
        Model.prototype.release = function () {
            _csm.free(this._ptr);
            this._ptr = 0;
        };
        return Model;
    }());
    Live2DCubismCore.Model = Model;
    /** Canvas information interface. */
    var CanvasInfo = /** @class */ (function () {
        /**
         * Initializes instance.
         *
         * @param modelPtr Native model pointer.
         */
        function CanvasInfo(modelPtr) {
            if (!modelPtr) {
                return;
            }
            // Preserve the pointer ant heap for get data throw args.
            var _canvasSize_data = new Float32Array(2);
            var _canvasSize_nDataBytes = _canvasSize_data.length * _canvasSize_data.BYTES_PER_ELEMENT;
            var _canvasSize_dataPtr = _csm.malloc(_canvasSize_nDataBytes);
            var _canvasSize_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasSize_dataPtr, _canvasSize_nDataBytes);
            _canvasSize_dataHeap.set(new Uint8Array(_canvasSize_data.buffer));
            var _canvasOrigin_data = new Float32Array(2);
            var _canvasOrigin_nDataBytes = _canvasOrigin_data.length * _canvasOrigin_data.BYTES_PER_ELEMENT;
            var _canvasOrigin_dataPtr = _csm.malloc(_canvasOrigin_nDataBytes);
            var _canvasOrigin_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasOrigin_dataPtr, _canvasOrigin_nDataBytes);
            _canvasOrigin_dataHeap.set(new Uint8Array(_canvasOrigin_data.buffer));
            var _canvasPPU_data = new Float32Array(1);
            var _canvasPPU_nDataBytes = _canvasPPU_data.length * _canvasPPU_data.BYTES_PER_ELEMENT;
            var _canvasPPU_dataPtr = _csm.malloc(_canvasPPU_nDataBytes);
            var _canvasPPU_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasPPU_dataPtr, _canvasPPU_nDataBytes);
            _canvasPPU_dataHeap.set(new Uint8Array(_canvasPPU_data.buffer));
            // Call function and get result
            _csm.readCanvasInfo(modelPtr, _canvasSize_dataHeap.byteOffset, _canvasOrigin_dataHeap.byteOffset, _canvasPPU_dataHeap.byteOffset);
            _canvasSize_data = new Float32Array(_canvasSize_dataHeap.buffer, _canvasSize_dataHeap.byteOffset, _canvasSize_dataHeap.length);
            _canvasOrigin_data = new Float32Array(_canvasOrigin_dataHeap.buffer, _canvasOrigin_dataHeap.byteOffset, _canvasOrigin_dataHeap.length);
            _canvasPPU_data = new Float32Array(_canvasPPU_dataHeap.buffer, _canvasPPU_dataHeap.byteOffset, _canvasPPU_dataHeap.length);
            this.CanvasWidth = _canvasSize_data[0];
            this.CanvasHeight = _canvasSize_data[1];
            this.CanvasOriginX = _canvasOrigin_data[0];
            this.CanvasOriginY = _canvasOrigin_data[1];
            this.PixelsPerUnit = _canvasPPU_data[0];
            // Free heap memory
            _csm.free(_canvasSize_dataHeap.byteOffset);
            _csm.free(_canvasOrigin_dataHeap.byteOffset);
            _csm.free(_canvasPPU_dataHeap.byteOffset);
        }
        return CanvasInfo;
    }());
    Live2DCubismCore.CanvasInfo = CanvasInfo;
    /** Cubism model parameters */
    var Parameters = /** @class */ (function () {
        /**
         * Initializes instance.
         *
         * @param modelPtr Native model.
         */
        function Parameters(modelPtr) {
            var length = 0;
            var length2 = null;
            this.count = _csm.getParameterCount(modelPtr);
            length = _csm.getParameterCount(modelPtr);
            this.ids = new Array(length);
            var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getParameterIds(modelPtr), length);
            for (var i = 0; i < _ids.length; i++) {
                this.ids[i] = _em.UTF8ToString(_ids[i]);
            }
            length = _csm.getParameterCount(modelPtr);
            this.minimumValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterMinimumValues(modelPtr), length);
            length = _csm.getParameterCount(modelPtr);
            this.maximumValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterMaximumValues(modelPtr), length);
            length = _csm.getParameterCount(modelPtr);
            this.defaultValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterDefaultValues(modelPtr), length);
            length = _csm.getParameterCount(modelPtr);
            this.values = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterValues(modelPtr), length);
            length = _csm.getParameterCount(modelPtr);
            this.keyCounts = new Int32Array(_em.HEAP32.buffer, _csm.getParameterKeyCounts(modelPtr), length);
            length = _csm.getParameterCount(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, _csm.getParameterKeyCounts(modelPtr), length);
            this.keyValues = new Array(length);
            var _keyValues = new Uint32Array(_em.HEAPU32.buffer, _csm.getParameterKeyValues(modelPtr), length);
            for (var i = 0; i < _keyValues.length; i++) {
                this.keyValues[i] = new Float32Array(_em.HEAPF32.buffer, _keyValues[i], length2[i]);
            }
        }
        return Parameters;
    }());
    Live2DCubismCore.Parameters = Parameters;
    /** Cubism model parts */
    var Parts = /** @class */ (function () {
        /**
         * Initializes instance.
         *
         * @param modelPtr Native model.
         */
        function Parts(modelPtr) {
            var length = 0;
            this.count = _csm.getPartCount(modelPtr);
            length = _csm.getPartCount(modelPtr);
            this.ids = new Array(length);
            var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getPartIds(modelPtr), length);
            for (var i = 0; i < _ids.length; i++) {
                this.ids[i] = _em.UTF8ToString(_ids[i]);
            }
            length = _csm.getPartCount(modelPtr);
            this.opacities = new Float32Array(_em.HEAPF32.buffer, _csm.getPartOpacities(modelPtr), length);
            length = _csm.getPartCount(modelPtr);
            this.parentIndices = new Int32Array(_em.HEAP32.buffer, _csm.getPartParentPartIndices(modelPtr), length);
        }
        return Parts;
    }());
    Live2DCubismCore.Parts = Parts;
    /** Cubism model drawables */
    var Drawables = /** @class */ (function () {
        /**
         * Initializes instance.
         *
         * @param modelPtr Native model.
         */
        function Drawables(modelPtr) {
            this._modelPtr = modelPtr;
            var length = 0;
            var length2 = null;
            this.count = _csm.getDrawableCount(modelPtr);
            length = _csm.getDrawableCount(modelPtr);
            this.ids = new Array(length);
            var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableIds(modelPtr), length);
            for (var i = 0; i < _ids.length; i++) {
                this.ids[i] = _em.UTF8ToString(_ids[i]);
            }
            length = _csm.getDrawableCount(modelPtr);
            this.constantFlags = new Uint8Array(_em.HEAPU8.buffer, _csm.getDrawableConstantFlags(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.dynamicFlags = new Uint8Array(_em.HEAPU8.buffer, _csm.getDrawableDynamicFlags(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.textureIndices = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableTextureIndices(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.drawOrders = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableDrawOrders(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.renderOrders = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableRenderOrders(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.opacities = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableOpacities(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.maskCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableMaskCounts(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.vertexCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            this.indexCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableIndexCounts(modelPtr), length);
            length = _csm.getDrawableCount(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableMaskCounts(modelPtr), length);
            this.masks = new Array(length);
            var _masks = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableMasks(modelPtr), length);
            for (var i = 0; i < _masks.length; i++) {
                this.masks[i] = new Int32Array(_em.HEAP32.buffer, _masks[i], length2[i]);
            }
            length = _csm.getDrawableCount(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
            this.vertexPositions = new Array(length);
            var _vertexPositions = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableVertexPositions(modelPtr), length);
            for (var i = 0; i < _vertexPositions.length; i++) {
                this.vertexPositions[i] = new Float32Array(_em.HEAPF32.buffer, _vertexPositions[i], length2[i] * 2);
            }
            length = _csm.getDrawableCount(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
            this.vertexUvs = new Array(length);
            var _vertexUvs = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableVertexUvs(modelPtr), length);
            for (var i = 0; i < _vertexUvs.length; i++) {
                this.vertexUvs[i] = new Float32Array(_em.HEAPF32.buffer, _vertexUvs[i], length2[i] * 2);
            }
            length = _csm.getDrawableCount(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableIndexCounts(modelPtr), length);
            this.indices = new Array(length);
            var _indices = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableIndices(modelPtr), length);
            for (var i = 0; i < _indices.length; i++) {
                this.indices[i] = new Uint16Array(_em.HEAPU16.buffer, _indices[i], length2[i]);
            }
        }
        /** Resets all dynamic drawable flags.. */
        Drawables.prototype.resetDynamicFlags = function () {
            _csm.resetDrawableDynamicFlags(this._modelPtr);
        };
        return Drawables;
    }());
    Live2DCubismCore.Drawables = Drawables;
    /** Utility functions. */
    var Utils = /** @class */ (function () {
        function Utils() {
        }
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasBlendAdditiveBit = function (bitfield) {
            return (bitfield & (1 << 0)) == (1 << 0);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasBlendMultiplicativeBit = function (bitfield) {
            return (bitfield & (1 << 1)) == (1 << 1);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasIsDoubleSidedBit = function (bitfield) {
            return (bitfield & (1 << 2)) == (1 << 2);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasIsInvertedMaskBit = function (bitfield) {
            return (bitfield & (1 << 3)) == (1 << 3);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasIsVisibleBit = function (bitfield) {
            return (bitfield & (1 << 0)) == (1 << 0);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasVisibilityDidChangeBit = function (bitfield) {
            return (bitfield & (1 << 1)) == (1 << 1);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasOpacityDidChangeBit = function (bitfield) {
            return (bitfield & (1 << 2)) == (1 << 2);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasDrawOrderDidChangeBit = function (bitfield) {
            return (bitfield & (1 << 3)) == (1 << 3);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasRenderOrderDidChangeBit = function (bitfield) {
            return (bitfield & (1 << 4)) == (1 << 4);
        };
        /**
         * Checks whether flag is set in bitfield.
         *
         * @param bitfield Bitfield to query against.
         *
         * @return [[true]] if bit set; [[false]] otherwise
        */
        Utils.hasVertexPositionsDidChangeBit = function (bitfield) {
            return (bitfield & (1 << 5)) == (1 << 5);
        };
        return Utils;
    }());
    Live2DCubismCore.Utils = Utils;
})(Live2DCubismCore || (Live2DCubismCore = {}));